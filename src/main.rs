use std::env;

use actix_web::{web, App, HttpResponse, HttpServer, Responder};
use futures::stream::TryStreamExt;
use mongodb::{
    bson::{doc, oid::ObjectId},
    Client,
};
use serde::{Deserialize, Serialize};

use serde::ser::Serializer;
use serde::Deserializer;

// Implement custom deserialization for the Qualities struct
// This is necessary because the Qualities struct is stored as a string in the database
// and we need to parse it into a struct with fields
// The string format is "name|color|windows_count"
// The deserialization function will take the string and split it into the three fields
fn deserialize_qualities<'de, D>(deserializer: D) -> Result<Qualities, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    let values: Vec<&str> = s.split("|").collect();

    if values.len() != 3 {
        return Err(serde::de::Error::custom(
            "Invalid formatted qualities value",
        ));
    }

    let windows_count = values[2].parse();

    if windows_count.is_err() {
        return Err(serde::de::Error::custom(
            "Invalid formatted value for number of windows on the ship",
        ));
    }

    Ok(Qualities {
        name: values[0].into(),
        color: values[1].into(),
        windows: windows_count.unwrap(),
    })
}

// Implement custom serialization for the Qualities struct
// This is necessary because the Qualities struct is stored as a string in the database
// and we need to convert it into a string with the format "name|color|windows_count"
// The serialization function will take the struct and convert it into a string
// The string format is "name|color|windows_count"
impl Serialize for Qualities {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(format!("{}|{}|{}", self.name, self.color, self.windows).as_str())
    }
}

// The Qualities struct is used to store the qualities of the shipwreck
// It is a custom struct with three fields: name, color, and windows
// The name and color fields are strings, and the windows field is an unsigned integer
#[derive(Deserialize, Debug)]
struct Qualities {
    name: String,
    color: String,
    windows: usize,
}

// The ShipwreckRecord struct is the format we want to store in the database
// It is a different format than the ShipwreckApiResponse struct
// The ShipwreckRecord struct has an ObjectId field for the ID
// The ObjectId field is generated by MongoDB when we insert a new document
#[derive(Serialize, Deserialize, Debug)]
struct ShipwreckRecord {
    #[serde(skip_serializing_if = "Option::is_none")]
    _id: Option<ObjectId>,
    recrd: String,
    vesslterms: String,
    feature_type: String,
    chart: String,
    latdec: f64,
    londec: f64,
    gp_quality: String,
    depth: f64,
    sounding_type: String,
    history: String,
    quasou: String,
    watlev: String,
    coordinates: (f64, f64),
    #[serde(deserialize_with = "deserialize_qualities")]
    qualities: Qualities,
}

// ShipwreckApiResponse is the response format we want to return to the client
// It is a different format than the ShipwreckRecord struct
#[derive(Serialize, Deserialize, Debug)]
struct ShipwreckApiResponse {
    #[serde(rename = "id")]
    _id: String,
    recrd: String,
    vesslterms: String,
    feature_type: String,
    chart: String,
    latdec: f64,
    londec: f64,
    gp_quality: String,
    depth: f64,
    sounding_type: String,
    history: String,
    quasou: String,
    watlev: String,

    qualities: Qualities,
}

// Implement conversion from ShipwreckRecord to ShipwreckApiResponse
// This is necessary because we want to return a response with a different format
// The conversion function will take the ShipwreckRecord struct and convert it into a ShipwreckApiResponse struct
impl From<ShipwreckRecord> for ShipwreckApiResponse {
    fn from(record: ShipwreckRecord) -> Self {
        ShipwreckApiResponse {
            _id: record
                ._id
                .map(|id| id.to_hex())
                .unwrap_or_else(|| "No ID".to_string()),
            recrd: record.recrd,
            vesslterms: record.vesslterms,
            feature_type: record.feature_type,
            chart: record.chart,
            latdec: record.latdec,
            londec: record.londec,
            gp_quality: record.gp_quality,
            depth: record.depth,
            sounding_type: record.sounding_type,
            history: record.history,
            quasou: record.quasou,
            watlev: record.watlev,
            qualities: record.qualities,
        }
    }
}

// The AppState struct is used to store the MongoDB client, database name, and collection name
// It is passed to each handler function as a web::Data<AppState> parameter
#[derive(Clone)]
struct AppState {
    client: Client,
    db_name: String,
    collection_name: String,
}

// create_shipwreck is the handler function for the POST /shipwrecks endpoint
// It takes a ShipwreckRecord struct as input and inserts it into the database
async fn create_shipwreck(
    state: web::Data<AppState>,
    shipwreck: web::Json<ShipwreckRecord>,
) -> Result<HttpResponse, actix_web::Error> {
    let collection = state
        .client
        .database(state.db_name.as_str())
        .collection(state.collection_name.as_str());
    let inner = shipwreck.into_inner();
    dbg!(&inner);
    let result = collection
        .insert_one(inner)
        .await
        .map_err(actix_web::error::ErrorInternalServerError)?;
    if let Some(new_id) = result.inserted_id.as_object_id() {
        Ok(HttpResponse::Created().json(doc! { "_id": new_id.to_hex() }))
    } else {
        Ok(HttpResponse::InternalServerError().finish())
    }
}

// update_shipwreck is the handler function for the PUT /shipwrecks/{id} endpoint
// It takes a ShipwreckRecord struct as input and updates the document with the given ID in the database
async fn update_shipwreck(
    state: web::Data<AppState>,
    path: web::Path<String>,
    shipwreck: web::Json<ShipwreckRecord>,
) -> Result<HttpResponse, actix_web::Error> {
    let id_str = path.into_inner();
    let object_id =
        ObjectId::parse_str(&id_str).map_err(|_| actix_web::error::ErrorBadRequest("Invalid ID"))?;
    let collection = state
        .client
        .database(state.db_name.as_str())
        .collection::<ShipwreckRecord>(state.collection_name.as_str());

    let update_result = collection
        .replace_one(doc! { "_id": object_id }, shipwreck.into_inner())
        .await
        .map_err(|_| actix_web::error::ErrorInternalServerError("Unable to update document"))?;

    if update_result.matched_count > 0 {
        Ok(HttpResponse::Ok().json(doc! { "modified_count": update_result.modified_count as i64 }))
    } else {
        Ok(HttpResponse::NotFound().body(format!("Shipwreck with ID {} not found", id_str)))
    }
}

// get_all_shipwrecks is the handler function for the GET /shipwrecks endpoint
// It retrieves all shipwrecks from the database and returns them as a JSON array of ShipwreckApiResponse structs
async fn get_all_shipwrecks(state: web::Data<AppState>) -> Result<HttpResponse, actix_web::Error> {
    let collection = state
        .client
        .database(state.db_name.as_str())
        .collection(state.collection_name.as_str());
    let cursor = collection
        .find(doc! {})
        .await
        .map_err(actix_web::error::ErrorInternalServerError)?;
    let wrecks: Vec<ShipwreckRecord> = cursor
        .try_collect()
        .await
        .map_err(actix_web::error::ErrorInternalServerError)?;
    Ok(HttpResponse::Ok().json(wrecks))
}

// get_shipwreck is the handler function for the GET /shipwrecks/{id} endpoint
// It retrieves a shipwreck with the given ID from the database and returns it as a ShipwreckApiResponse struct
async fn get_shipwreck(
    state: web::Data<AppState>,
    path: web::Path<String>,
) -> Result<HttpResponse, actix_web::Error> {
    let id_str = path.into_inner();
    let object_id =
        ObjectId::parse_str(&id_str).map_err(|_| actix_web::error::ErrorBadRequest("Invalid ID"))?;
    let collection = state
        .client
        .database(state.db_name.as_str())
        .collection::<ShipwreckRecord>(state.collection_name.as_str());
    let wreck = collection
        .find_one(doc! { "_id": object_id })
        .await
        .map_err(actix_web::error::ErrorInternalServerError)?;

    match wreck {
        Some(w) => Ok(HttpResponse::Ok().json(ShipwreckApiResponse::from(w))),
        None => {
            Ok(HttpResponse::NotFound().body(format!("Shipwreck with ID {} not found", id_str)))
        }
    }
}

// delete_shipwreck is the handler function for the DELETE /shipwrecks/{id} endpoint
// It deletes the shipwreck with the given ID from the database
// It returns a success message if the shipwreck was deleted, or a 404 error if it was not found
async fn delete_shipwreck(
    state: web::Data<AppState>,
    path: web::Path<String>,
) -> Result<HttpResponse, actix_web::Error> {
    let id_str = path.into_inner();
    let object_id =
        ObjectId::parse_str(&id_str).map_err(|_| actix_web::error::ErrorBadRequest("Invalid ID"))?;
    let collection = state
        .client
        .database(state.db_name.as_str())
        .collection::<ShipwreckRecord>(state.collection_name.as_str());
    let delete_result = collection
        .delete_one(doc! { "_id": object_id })
        .await
        .map_err(actix_web::error::ErrorInternalServerError)?;

    if delete_result.deleted_count > 0 {
        Ok(HttpResponse::Ok().json(doc! {"status": format!("successfully deleted {}", id_str)}))
    } else {
        Ok(HttpResponse::NotFound().body(format!("Shipwreck with ID {} not found", id_str)))
    }
}

// ping is a simple health check endpoint that returns "pong!" when accessed
async fn ping() -> impl Responder {
    HttpResponse::Ok().body("pong!")
}

// main function initializes the Actix web server and MongoDB client
// It sets up the routes and starts the server on port 8080
#[tokio::main]
async fn main() -> std::result::Result<(), mongodb::error::Error> {
    dotenvy::dotenv().unwrap();
    let mongodb_uri = env::var("MONGODB_URI").unwrap();
    let client = Client::with_uri_str(mongodb_uri).await?;
    let db_name = "sample_geospatial";
    let collection_name = "shipwrecks";

    let app_state = AppState {
        client: client.clone(),
        db_name: db_name.into(),
        collection_name: collection_name.into(),
    };

    println!("Starting server on port 8080");

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .route("/ping", web::get().to(ping))
            .route("/shipwrecks", web::post().to(create_shipwreck))
            .route("/shipwrecks", web::get().to(get_all_shipwrecks))
            .route("/shipwrecks/{id}", web::get().to(get_shipwreck))
            .route("/shipwrecks/{id}", web::put().to(update_shipwreck))
            .route("/shipwrecks/{id}", web::delete().to(delete_shipwreck))
    })
    .bind(("127.0.0.1", 8080))?
    .run()
    .await?;

    Ok(())
}
